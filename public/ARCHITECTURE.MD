## Как устроено это приложение?

Основная идея - разделить приложение на слои, каждый из которых обладает определенными ограничениями. Основная цель - ограничить возможные варианты реализовать одно и тоже разными способами.

### Слои
__1. Экземпляр апи (api-instance)__  
Выполняет функцию интерфейса на REST-api бекендом. Осуществляет запросы к бекенду посредством axios. В качестве интерфейса использования предоставляет функцию ___getExistingApiInstance___, которая возвращает объект с доступными методами. Не имеет доступа к store, router, i18n и другим частям приложения. Единственный элемент управления снаружи - возможность динамически добавлять и убирать интерцепторы(interceptors) посредством функций в файле `api/interceptor-service`

__2. Use-функции (composibles)__  
Прослойка между api-instance и остальной частью приложения. Все запросы к api должны проходить через них. Дело в том, что методы, представляемые экземпляром апи (слой 1) повторяют REST-архитектуру приложения, которая часто не соответствует требуемому визуальному интерфейсу. Use-функции фактически должны давать остальному приложению взаимодействовать с более удобными для визуального интерфейса структурами. Фактически, это отдаленно похоже на функциональность DTO(data-transfer-object).

Сами функции должны быть "чистыми" - всего лишь возвращать набор доступных для данной сущности методы. На самом деле, это абстрактные классы со статическими методами, но реализованные в виде функций (тк дальнейшие слои используют ES5-классы, во избежание путаницы тут оставлены функции)

Не должны иметь доступ к store, router, i18n. Никакие другие слои не имеют доступ к api-instance кроме этого.

__3. Сервисы (Services)__  
Классы, содержащие в себе методы для работы с бизнес-логикой. Могут быть как абстрактными, так и "реальными", могут содержать в себе реализацию сложной функциональности (процесс авторизации + регистрации) или предоставлять методы для работы с конкретной сущностью, или даже ее часть. Должны быть покрыты тестами. Имеет доступ к интерцепторам апи, к use-функциям, к store, router, i18n и всему остальному. Фактически, могут содержать в себе любые сайд-эффекты при необходимости. Основная идея - сконцентрировать в них бизнес-правила, которые можно задокументировать и покрыть unit-тестами.

__4. Представления__  
Vue-компоненты. Не должны содержать бизнес правил, кроме самых простых (если в компоненте нужно больше чем одно правило - нужно использовать слой сервисов). Тут нет жестких ограничений, кроме запрета на прямой доступ к экземпляру апи, но нельзя злоупотреблять управлением другими частями приложения из компонентов. Например, к store стоит обращаться только на чтение (доступ к state и getters), в некоторых случаях - к мутациям (в основном, к мутациям полей "флагов загрузки" (например - SET_IS_APP_LOADING)).

Мы стремимся также покрывать unit-тестами также и этот слой, и поэтому, из-за сложности работы с vue-test-utlis, крайне рекомендуется делать компоненты как можно более глупыми при возможности, и выносить бизнес-правила в сервисы

### Работа с состоянием.
Запрещается использовать vuex-store только как инструмент для хранилища кеша (данных с апи). В глобальном состоянии (состоянии приложения, ApplicationState) могут храниться данные, необходимые для работы всего приложения - например, данные авторизации.
Важный пункт - не используются vuex-actions, вместо них, большинство мутаций должно вызываться посредством сервисов, и в редких случаях, представлений

При старте приложения, в store загружаются данные о текущем домене, мероприятии и пользователе. Все другие необходимые состояния должны хранится там, где они нужны - например в компонентах, выполняющих функции страниц (router-views). Например, данные о материале (ранее эта сущность называлась "обращения", Requests) должны загружаются на странице материла, и хранится как состояние компонента-страницы.
Правило простое - если двум компонентам необходимы одни и те же данные, этими данными должен управлять их ближайший общий родитель в дереве компонентов. Под "управлять" имеется ввиду - загружать, отправлять, мутировать и тд. Если получается что их общим родителем становится корневая точка входа приложения (это произойдет, когда компоненты используются на разных страницах (router-views)) - то это верный знак того что эти данные являются ApplicationState и им место в vuex

документ не дописан, работа ведется...
